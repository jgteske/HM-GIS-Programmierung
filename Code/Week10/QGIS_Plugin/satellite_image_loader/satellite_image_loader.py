# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SatelliteImageLoader
                                 A QGIS plugin
 Use to load Images from Sentinel-1 GRD, Sentinel-2 Level-2A or Suomi-NPP VIIRS Day-Night-Band
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-01-07
        git sha              : $Format:%H$
        copyright            : (C) 2023 by jteske
        email                : jteske@hm.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Einladen der Packages
import sys
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QProcess
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QPushButton
from PyQt5 import QtWidgets
from datetime import date, timedelta
import webbrowser
import os.path
import os
import json
import requests
import glob
import shutil
import zipfile
import rasterio
from rasterio import warp
from rasterio import plot
from osgeo import gdal, ogr
import subprocess
from pyroSAR.snap import geocode
from sentinelsat import (
    SentinelAPI,
    geojson_to_wkt,
    read_geojson,
)

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .satellite_image_loader_dialog import SatelliteImageLoaderDialog
import os.path


class SatelliteImageLoader:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "SatelliteImageLoader_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&Satellite Image Loader")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("SatelliteImageLoader", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/satellite_image_loader/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("Sattelite Data"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&Satellite Image Loader"), action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SatelliteImageLoaderDialog()
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt_Willkommen)
        self.dlg.Schritt2.setEnabled(False)
        self.dlg.Schritt3.setEnabled(False)
        self.dlg.Schritt4.setEnabled(False)
        self.dlg.Schritt5.setEnabled(False)
        self.dlg.Schritt6.setEnabled(False)
        self.dlg.modifySentinel1.setEnabled(False)
        self.dlg.modifySentinel2.setEnabled(False)
        self.dlg.editVIIRS.setEnabled(False)
        self.dlg.editSentinel1.setEnabled(False)
        self.dlg.editSentinel2.setEnabled(False)
        self.dlg.acceptJSON.setEnabled(False)
        self.dlg.Schritt1.clicked.connect(self.Seite1)
        self.dlg.Schritt2.setStyleSheet("background-color: red")
        self.dlg.Schritt3.setStyleSheet("background-color: red")
        self.dlg.Schritt4.setStyleSheet("background-color: red")
        self.dlg.Schritt5.setStyleSheet("background-color: red")
        self.dlg.Schritt6.setStyleSheet("background-color: red")
        self.dlg.Schritt1_check.setHidden(True)
        self.dlg.Schritt2_check.setHidden(True)
        self.dlg.Schritt3_check.setHidden(True)
        self.dlg.Schritt4_check.setHidden(True)
        self.dlg.Schritt5_check.setHidden(True)
        # self.dlg.Helper_Sent2.setHidden(True)
        # self.dlg.Helper_Sent1.setHidden(True)
        # self.dlg.help_merge_VIIRS.setHidden(True)
        # self.dlg.help_merge_Sent1.setHidden(True)
        # self.dlg.help_merge_Sent2.setHidden(True)
        self.dlg.openWorkDir.clicked.connect(self.select_Workfolder)
        self.dlg.acceptWorkDir.clicked.connect(self.Best_Button1)
        self.dlg.Schritt2.clicked.connect(self.Seite2)
        self.dlg.selectJSON.clicked.connect(self.GeoJSON)
        self.dlg.acceptJSON.clicked.connect(self.MoveGeoJSON)
        self.dlg.Schritt3.clicked.connect(self.Seite3)
        self.dlg.acceptDate.clicked.connect(self.Datum)
        self.dlg.selectVIRRS.setEnabled(False)
        self.dlg.selectSentinel1.setEnabled(False)
        self.dlg.selectSenintel2.setEnabled(False)
        self.dlg.startDownload.setEnabled(False)
        self.dlg.startDownload.clicked.connect(self.downloadData)
        self.dlg.Schritt4.clicked.connect(self.Seite4)
        self.dlg.modifySentinel1.clicked.connect(self.GeocodeSentinel1)
        self.dlg.modifySentinel2.clicked.connect(self.GeocodeSentinel2)
        self.dlg.Schritt5.clicked.connect(self.Seite5)
        self.dlg.editVIIRS.clicked.connect(self.ClipVIIRS)
        self.dlg.editSentinel1.clicked.connect(self.Merge_Clip_Sentinel1)
        self.dlg.editSentinel2.clicked.connect(self.Merge_Clip_Sentinel2)
        self.dlg.Schritt6.clicked.connect(self.Seite6)
        self.dlg.backToDownload.clicked.connect(self.ReturnSeite3)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    # Öffnen der erste Seite
    def Seite1(self):
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt1_Widget)
        self.dlg.Schritt1.setEnabled(False)

    # Erstellen des Arbeitsverzeichnises
    def select_Workfolder(self):
        self.dlg.openWorkDir.setEnabled(False)
        dir = QtWidgets.QFileDialog.getExistingDirectory(None, "Select a folder:")
        self.dlg.workDir.setText(dir)
        self.Workpath = dir
        if not os.path.exists(self.Workpath):
            os.mkdir(self.Workpath)
        if not os.path.exists("" + self.Workpath + r"/Geojson"):
            os.mkdir("" + self.Workpath + r"/Geojson")
        if not os.path.exists("" + self.Workpath + r"/Downloadfiles"):
            os.mkdir("" + self.Workpath + r"/Downloadfiles")
        if not os.path.exists("" + self.Workpath + r"/EditTiles"):
            os.mkdir("" + self.Workpath + r"/EditTiles")
        if not os.path.exists("" + self.Workpath + r"/GeoTIFFs"):
            os.mkdir("" + self.Workpath + r"/GeoTIFFs")

    # Freischalten und Überprüfen des nächsten Schritts
    def Best_Button1(self):
        if os.path.exists(self.Workpath):
            os.chdir(self.Workpath)
            # self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt2_Widget)
            self.Seite2()

    # Öffnen der zweite Seite und überprüfen ob ein geoJSON-File bereits existiert
    def Seite2(self):
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt2_Widget)
        self.dlg.Schritt2.setEnabled(False)

    # Öffnen der Webseite zum Erstellen des geoJSON-Files
    def GeoJSON(self):
        webbrowser.open(r"https://geojson.io")
        self.dlg.selectJSON.setEnabled(False)
        self.dlg.acceptJSON.setEnabled(True)

    # Verschieben des GeoJSON in das Arbeitsverzeichnis und Benenne es um
    def MoveGeoJSON(self):
        self.dlg.acceptJSON.setEnabled(False)
        for dirpath, dirnames, filenames in os.walk(r"c:\\"):
            for filename in filenames:
                if filename.endswith("map.geojson"):
                    shutil.move(
                        ("" + dirpath + "/" + filename + ""),
                        ("" + self.Workpath + "/Geojson/Area_of_Interest.geojson"),
                    )

        if os.path.isfile("" + self.Workpath + "/Geojson/Area_of_Interest.geojson"):
            self.dlg.Schritt2_check.setHidden(False)
            self.dlg.Schritt3.setEnabled(True)
            self.dlg.Schritt2.setEnabled(False)
            self.dlg.Schritt2.setStyleSheet("background-color: green")
            self.dlg.Schritt3.setStyleSheet("")

    # Öffnen der dritten Seite
    def Seite3(self):
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt3_Widget)
        self.dlg.Schritt3.setEnabled(False)

    # Festlegen des Datums
    def Datum(self):
        if self.dlg.selectDate.date() >= date.today():
            self.dlg.lbl_day.setText(
                "Daten für das gewählte Datum sind noch nicht verfügbar!"
            )
        else:
            self.dlg.selectDate.setEnabled(False)
            self.dlg.acceptDate.setEnabled(False)
            self.jahr = self.dlg.selectDate.date().toString("yyyy")
            self.monat = self.dlg.selectDate.date().toString("MM")
            self.tag = self.dlg.selectDate.date().toString("dd")
            self.dlg.lbl_day.setText("")
            if not os.path.exists(
                ""
                + self.Workpath
                + r"/Downloadfiles/"
                + self.jahr
                + self.monat
                + self.tag
            ):
                os.mkdir(
                    ""
                    + self.Workpath
                    + r"/Downloadfiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                )
                if not os.path.exists(
                    ""
                    + self.Workpath
                    + r"/GeoTIFFs/"
                    + self.jahr
                    + self.monat
                    + self.tag
                ):
                    os.mkdir(
                        ""
                        + self.Workpath
                        + r"/GeoTIFFs/"
                        + self.jahr
                        + self.monat
                        + self.tag
                    )
                self.dlg.selectVIRRS.setEnabled(True)
                self.dlg.selectSentinel1.setEnabled(True)
                self.dlg.selectSenintel2.setEnabled(True)
                self.dlg.startDownload.setEnabled(True)
            else:
                self.dlg.lbl_day.setText("Datum wurde bereits runtergeladen")
                self.dlg.selectDate.setEnabled(True)
                self.dlg.acceptDate.setEnabled(True)

    # Herunterladen der Daten zum ausgewählten Datum
    def downloadData(self):
        self.dlg.startDownload.setEnabled(False)
        if not os.path.exists(
            "" + self.Workpath + r"/EditTiles/" + self.jahr + self.monat + self.tag
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + ""
            )
        if (
            not self.dlg.selectVIRRS.isChecked()
            or self.dlg.selectSentinel1.isChecked()
            or self.dlg.selectSenintel2.isChecked()
        ):
            self.dlg.lbl_day.setText("Keine Satelliten-Missionen ausgewählt")
            self.dlg.startDownload.setEnabled(True)
        if (
            self.dlg.selectVIRRS.isChecked()
            or self.dlg.selectSentinel1.isChecked()
            or self.dlg.selectSenintel2.isChecked()
        ):
            self.dlg.lbl_day.setText("")
            # startDownload der VIIRS Daten
            # Basis: https://payneinstitute.mines.edu/eog-2/transition-to-secured-data-access/
            if self.dlg.selectVIRRS.isChecked():
                if not os.path.exists(
                    ""
                    + self.Workpath
                    + r"/Downloadfiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/VIIRS"
                ):
                    os.mkdir(
                        ""
                        + self.Workpath
                        + r"/Downloadfiles/"
                        + self.jahr
                        + self.monat
                        + self.tag
                        + "/VIIRS"
                    )
                    params = {
                        "client_id": "eogdata_oidc",
                        "client_secret": "2677ad81-521b-4869-8480-6d05b9e57d48",
                        "username": "downloadtool.sat.data@gmail.com",
                        "password": "Satellitenbilder",
                        "grant_type": "password",
                    }
                    year = self.jahr
                    month = self.monat
                    day = self.tag
                    token_url = "https://eogauth.mines.edu/auth/realms/master/protocol/openid-connect/token"
                    response = requests.post(token_url, data=params)
                    access_token_dict = json.loads(response.text)
                    access_token = access_token_dict.get("access_token")
                    data_url = (
                        "https://eogdata.mines.edu/nighttime_light/nightly/rade9d/SVDNB_npp_d"
                        + year
                        + month
                        + day
                        + ".rade9d.tif"
                    )
                    auth = "Bearer " + access_token
                    headers = {"Authorization": auth}
                    response = requests.get(data_url, headers=headers)

                    with open(
                        (
                            ""
                            + self.Workpath
                            + r"/Downloadfiles/"
                            + self.jahr
                            + self.monat
                            + self.tag
                            + "/VIIRS/NightLights"
                            + year
                            + month
                            + day
                            + ".tif"
                        ),
                        "wb",
                    ) as f:
                        f.write(response.content)

                    if os.path.isfile(
                        ""
                        + self.Workpath
                        + r"/Downloadfiles/"
                        + self.jahr
                        + self.monat
                        + self.tag
                        + "/VIIRS/NightLights"
                        + year
                        + month
                        + day
                        + ".tif"
                    ):
                        self.dlg.lbl_dl_VIIRS.setText("VIIRS heruntergeladen")
                else:
                    self.dlg.lbl_dl_VIIRS.setText(
                        "VIIRS-Daten für Datum bereits heruntergeladen"
                    )
            # startDownload von Sentinel-1 Daten
            if self.dlg.selectSentinel1.isChecked():
                os.mkdir(
                    ""
                    + self.Workpath
                    + r"/Downloadfiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel1"
                )
                sys.stderr = open("err.txt", "w")
                sys.stdout = open("err.txt", "w")
                if self.dlg.selectSentinel1Options.currentText() == "Beide Satelliten":
                    Abstand_Sent1 = 2
                else:
                    Abstand_Sent1 = 3
                Tag_Sent1 = int(self.tag)
                Monat_Sent1 = int(self.monat)
                Jahr_Sent1 = int(self.jahr)
                Startdate_Sent1 = date(Jahr_Sent1, Monat_Sent1, Tag_Sent1) - timedelta(
                    days=Abstand_Sent1
                )
                Enddate_Sent1 = date(Jahr_Sent1, Monat_Sent1, Tag_Sent1) + timedelta(
                    days=Abstand_Sent1
                )

                Startday_Sent1 = Startdate_Sent1.day
                Startmonth_Sent1 = Startdate_Sent1.month
                Startyear_Sent1 = Startdate_Sent1.year

                Endday_Sent1 = Enddate_Sent1.day
                Endmonth_Sent1 = Enddate_Sent1.month
                Endyear_Sent1 = Enddate_Sent1.year

                if Startmonth_Sent1 < 10 and Startday_Sent1 < 10:
                    Beginning_Sent1 = (
                        ""
                        + str(Startyear_Sent1)
                        + "0"
                        + str(Startmonth_Sent1)
                        + "0"
                        + str(Startday_Sent1)
                        + ""
                    )
                if Startmonth_Sent1 >= 10 and Startday_Sent1 < 10:
                    Beginning_Sent1 = (
                        ""
                        + str(Startyear_Sent1)
                        + str(Startmonth_Sent1)
                        + "0"
                        + str(Startday_Sent1)
                        + ""
                    )
                if Startmonth_Sent1 >= 10 and Startday_Sent1 >= 10:
                    Beginning_Sent1 = (
                        ""
                        + str(Startyear_Sent1)
                        + str(Startmonth_Sent1)
                        + str(Startday_Sent1)
                        + ""
                    )
                if Startmonth_Sent1 < 10 and Startday_Sent1 >= 10:
                    Beginning_Sent1 = (
                        ""
                        + str(Startyear_Sent1)
                        + "0"
                        + str(Startmonth_Sent1)
                        + str(Startday_Sent1)
                        + ""
                    )

                if Endmonth_Sent1 < 10 and Endday_Sent1 < 10:
                    Ending_Sent1 = (
                        ""
                        + str(Endyear_Sent1)
                        + "0"
                        + str(Endmonth_Sent1)
                        + "0"
                        + str(Endday_Sent1)
                        + ""
                    )
                if Endmonth_Sent1 >= 10 and Endday_Sent1 < 10:
                    Ending_Sent1 = (
                        ""
                        + str(Endyear_Sent1)
                        + str(Endmonth_Sent1)
                        + "0"
                        + str(Endday_Sent1)
                        + ""
                    )
                if Endmonth_Sent1 >= 10 and Endday_Sent1 >= 10:
                    Ending_Sent1 = (
                        ""
                        + str(Endyear_Sent1)
                        + str(Endmonth_Sent1)
                        + str(Endday_Sent1)
                        + ""
                    )
                if Endmonth_Sent1 < 10 and Endday_Sent1 >= 10:
                    Ending_Sent1 = (
                        ""
                        + str(Endyear_Sent1)
                        + "0"
                        + str(Endmonth_Sent1)
                        + str(Endday_Sent1)
                        + ""
                    )

                # Nur Satellitenbilder von Sentinel-1A Satelliten
                if self.dlg.selectSentinel1Options.currentText() == "S1A":
                    api = SentinelAPI("downloadtool.sat.data", "Satellitenbilder")
                    # search by polygon, time, and Hub query keywords
                    footprint = geojson_to_wkt(
                        read_geojson(
                            "" + self.Workpath + "/Geojson/Area_of_Interest.geojson"
                        )
                    )
                    products = api.query(
                        footprint,
                        date=(Beginning_Sent1, Ending_Sent1),
                        platformname="Sentinel-1",
                        producttype="GRD",
                        limit=4,
                        filename="S1A*",
                    )

                    for item in products.keys():
                        api.download(
                            item,
                            directory_path=""
                            + self.Workpath
                            + r"/Downloadfiles/"
                            + self.jahr
                            + self.monat
                            + self.tag
                            + r"/Sentinel1",
                        )

                # Nur Satellitenbilder von Sentinel-1B Satelliten
                if self.dlg.selectSentinel1Options.currentText() == "S1B":
                    api = SentinelAPI("downloadtool.sat.data", "Satellitenbilder")
                    # search by polygon, time, and Hub query keywords
                    footprint = geojson_to_wkt(
                        read_geojson(
                            "" + self.Workpath + "/Geojson/Area_of_Interest.geojson"
                        )
                    )
                    products = api.query(
                        footprint,
                        date=(Beginning_Sent1, Ending_Sent1),
                        platformname="Sentinel-1",
                        producttype="GRD",
                        limit=4,
                        filename="S1B*",
                    )

                    for item in products.keys():
                        api.download(
                            item,
                            directory_path=""
                            + self.Workpath
                            + r"/Downloadfiles/"
                            + self.jahr
                            + self.monat
                            + self.tag
                            + r"/Sentinel1",
                        )

                # Beide Satelelliten
                if self.dlg.selectSentinel1Options.currentText() == "Beide Satelliten":
                    api = SentinelAPI("downloadtool.sat.data", "Satellitenbilder")
                    # search by polygon, time, and Hub query keywords
                    footprint = geojson_to_wkt(
                        read_geojson(
                            "" + self.Workpath + "/Geojson/Area_of_Interest.geojson"
                        )
                    )
                    products = api.query(
                        footprint,
                        date=(Beginning_Sent1, Ending_Sent1),
                        platformname="Sentinel-1",
                        producttype="GRD",
                        limit=4,
                    )

                    for item in products.keys():
                        api.download(
                            item,
                            directory_path=""
                            + self.Workpath
                            + r"/Downloadfiles/"
                            + self.jahr
                            + self.monat
                            + self.tag
                            + r"/Sentinel1",
                        )

                # Bestätigung startDownload
                if os.path.isdir(
                    ""
                    + self.Workpath
                    + r"/Downloadfiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + r"/Sentinel1/"
                ):
                    self.dlg.lbl_dl_Sent1.setText("Sentinel-1 heruntergeladen")

            # startDownload von Sentinel-2 Daten und entpacken
            if self.dlg.selectSenintel2.isChecked():
                if not os.path.exists(
                    ""
                    + self.Workpath
                    + r"/Downloadfiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel2"
                ):
                    os.mkdir(
                        ""
                        + self.Workpath
                        + r"/Downloadfiles/"
                        + self.jahr
                        + self.monat
                        + self.tag
                        + "/Sentinel2"
                    )
                sys.stderr = open("err.txt", "w")
                sys.stdout = open("err.txt", "w")
                Abstand_Sent2 = 3
                Tag_Sent2 = int(self.tag)
                Monat_Sent2 = int(self.monat)
                Jahr_Sent2 = int(self.jahr)
                Startdate_Sent2 = date(Jahr_Sent2, Monat_Sent2, Tag_Sent2) - timedelta(
                    days=Abstand_Sent2
                )
                Enddate_Sent2 = date(Jahr_Sent2, Monat_Sent2, Tag_Sent2) + timedelta(
                    days=Abstand_Sent2
                )

                Startday_Sent2 = Startdate_Sent2.day
                Startmonth_Sent2 = Startdate_Sent2.month
                Startyear_Sent2 = Startdate_Sent2.year

                Endday_Sent2 = Enddate_Sent2.day
                Endmonth_Sent2 = Enddate_Sent2.month
                Endyear_Sent2 = Enddate_Sent2.year

                if Startmonth_Sent2 < 10 and Startday_Sent2 < 10:
                    Beginning_Sent2 = (
                        ""
                        + str(Startyear_Sent2)
                        + "0"
                        + str(Startmonth_Sent2)
                        + "0"
                        + str(Startday_Sent2)
                        + ""
                    )
                if Startmonth_Sent2 >= 10 and Startday_Sent2 < 10:
                    Beginning_Sent2 = (
                        ""
                        + str(Startyear_Sent2)
                        + str(Startmonth_Sent2)
                        + "0"
                        + str(Startday_Sent2)
                        + ""
                    )
                if Startmonth_Sent2 >= 10 and Startday_Sent2 >= 10:
                    Beginning_Sent2 = (
                        ""
                        + str(Startyear_Sent2)
                        + str(Startmonth_Sent2)
                        + str(Startday_Sent2)
                        + ""
                    )
                if Startmonth_Sent2 < 10 and Startday_Sent2 >= 10:
                    Beginning_Sent2 = (
                        ""
                        + str(Startyear_Sent2)
                        + "0"
                        + str(Startmonth_Sent2)
                        + str(Startday_Sent2)
                        + ""
                    )

                if Endmonth_Sent2 < 10 and Endday_Sent2 < 10:
                    Ending_Sent2 = (
                        ""
                        + str(Endyear_Sent2)
                        + "0"
                        + str(Endmonth_Sent2)
                        + "0"
                        + str(Endday_Sent2)
                        + ""
                    )
                if Endmonth_Sent2 >= 10 and Endday_Sent2 < 10:
                    Ending_Sent2 = (
                        ""
                        + str(Endyear_Sent2)
                        + str(Endmonth_Sent2)
                        + "0"
                        + str(Endday_Sent2)
                        + ""
                    )
                if Endmonth_Sent2 >= 10 and Endday_Sent2 >= 10:
                    Ending_Sent2 = (
                        ""
                        + str(Endyear_Sent2)
                        + str(Endmonth_Sent2)
                        + str(Endday_Sent2)
                        + ""
                    )
                if Endmonth_Sent2 < 10 and Endday_Sent2 >= 10:
                    Ending_Sent2 = (
                        ""
                        + str(Endyear_Sent2)
                        + "0"
                        + str(Endmonth_Sent2)
                        + str(Endday_Sent2)
                        + ""
                    )
                if self.dlg.selectSentinel2Options.currentText() == "S2A":
                    api = SentinelAPI("downloadtool.sat.data", "Satellitenbilder")
                    # search by polygon, time, and Hub query keywords
                    footprint = geojson_to_wkt(
                        read_geojson(
                            "" + self.Workpath + "/Geojson/Area_of_Interest.geojson"
                        )
                    )
                    products = api.query(
                        footprint,
                        date=(Beginning_Sent2, Ending_Sent2),
                        platformname="Sentinel-2",
                        producttype="S2MSI2A",
                        limit=4,
                        filename="S2A*",
                    )

                    for item in products.keys():
                        api.download(
                            item,
                            directory_path=""
                            + self.Workpath
                            + r"/Downloadfiles/"
                            + self.jahr
                            + self.monat
                            + self.tag
                            + r"/Sentinel2",
                        )
                if self.dlg.selectSentinel2Options.currentText() == "S2B":
                    api = SentinelAPI("downloadtool.sat.data", "Satellitenbilder")
                    # search by polygon, time, and Hub query keywords
                    footprint = geojson_to_wkt(
                        read_geojson(
                            "" + self.Workpath + "/Geojson/Area_of_Interest.geojson"
                        )
                    )
                    products = api.query(
                        footprint,
                        date=(Beginning_Sent2, Ending_Sent2),
                        platformname="Sentinel-2",
                        producttype="S2MSI2A",
                        limit=4,
                        filename="S2B*",
                    )

                    for item in products.keys():
                        api.download(
                            item,
                            directory_path=""
                            + self.Workpath
                            + r"/Downloadfiles/"
                            + self.jahr
                            + self.monat
                            + self.tag
                            + r"/Sentinel2",
                        )

                if not os.path.exists(
                    ""
                    + self.Workpath
                    + r"/EditTiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel2"
                ):
                    os.mkdir(
                        ""
                        + self.Workpath
                        + r"/EditTiles/"
                        + self.jahr
                        + self.monat
                        + self.tag
                        + "/Sentinel2"
                    )
                    os.mkdir(
                        ""
                        + self.Workpath
                        + r"/EditTiles/"
                        + self.jahr
                        + self.monat
                        + self.tag
                        + "/Sentinel2/SingleTiles"
                    )

                # Zählen der Datensätze
                path_Sent2 = (
                    ""
                    + self.Workpath
                    + r"/Downloadfiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + r"/Sentinel2/"
                )
                tilessum = sum(
                    os.path.isfile(os.path.join(path_Sent2, i))
                    for i in os.listdir(path_Sent2)
                )
                # Entpacken der .zip-Dateien
                Entpackungsliste = []

                for zipListe in sorted(
                    glob.glob(
                        (
                            ""
                            + self.Workpath
                            + r"/Downloadfiles/"
                            + self.jahr
                            + self.monat
                            + self.tag
                            + r"/Sentinel2/*.zip"
                        )
                    )
                ):
                    Entpackungsliste.append(zipListe)

                for unzipper in range(1, tilessum + 1):
                    with zipfile.ZipFile(Entpackungsliste[unzipper - 1], "r") as zipObj:
                        # Extract all the contents of zip file in different directory
                        zipObj.extractall(
                            (
                                ""
                                + self.Workpath
                                + r"/Downloadfiles/"
                                + self.jahr
                                + self.monat
                                + self.tag
                                + r"/Sentinel2"
                            )
                        )
                    os.remove(Entpackungsliste[unzipper - 1])

                # Extrahieren der benötigten Bänder

    # Code ergänzen
    # Ein Band auslesen und einer Liste hinzufügen und das Band in einer Datei speichern
    # for name in sorted(glob.glob(
    #      ("" + self.Workpath + r"/Downloadfiles/" + self.jahr + self.monat + self.tag + r"/Sentinel2/*/*/*/*/*/*B02_10m.jp2"))):
    #      TilelistB.append(name)
    # shutil.copyfile(TileBlue1, ("" + self.Workpath + r"/EditTiles/" + self.jahr + self.monat + self.tag + "/Sentinel2/SingleTiles/BlueCTile1.jp2"))
    # Dieses Auslesen für die vier Bänder Blau Grün Rot NIR und bis zu vier Tiles

    # Öffnen der vierten Seite
    def Seite4(self):
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt4_Widget)
        self.dlg.Schritt4.setEnabled(False)

    # Geocoden der Sentinel1 Daten
    def GeocodeSentinel1(self):
        self.dlg.modifySentinel1.setEnabled(False)
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel1"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel1"
            )
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel1/GeocodedTiles"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel1/GeocodedTiles"
            )

        pathSent1 = (
            ""
            + self.Workpath
            + r"/Downloadfiles/"
            + self.jahr
            + self.monat
            + self.tag
            + r"/Sentinel1"
        )
        tilessum = sum(
            os.path.isfile(os.path.join(pathSent1, i)) for i in os.listdir(pathSent1)
        )

        # Geocoding durch Zugriff auf SNAP
        TilelistSent1 = []
        for name in sorted(
            glob.glob(
                ""
                + self.Workpath
                + r"/Downloadfiles/"
                + self.jahr
                + self.monat
                + self.tag
                + r"/Sentinel1/*.zip"
            )
        ):
            TilelistSent1.append(name)

        for Datensätze in range(1, tilessum + 1):
            outdir_Sent1 = (
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + r"/Sentinel1/GeocodedTiles"
            )
            geocode(
                infile=TilelistSent1[Datensätze - 1],
                outdir=outdir_Sent1,
                tr=10,
                scaling="dB",
                t_srs=4326,
            )

        self.dlg.Helper_Sent1.setChecked(False)
        if not self.dlg.Helper_Sent1.isChecked():
            if not self.dlg.Helper_Sent2.isChecked():
                self.dlg.Schritt4_check.setHidden(False)
                self.dlg.Schritt5.setEnabled(True)
                self.dlg.Schritt4.setStyleSheet("background-color: green")
                self.dlg.Schritt5.setStyleSheet("")
        if not self.dlg.Helper_Sent2.isChecked():
            if not self.dlg.Helper_Sent1.isChecked():
                self.dlg.Schritt4_check.setHidden(False)
                self.dlg.Schritt5.setEnabled(True)
                self.dlg.Schritt4.setStyleSheet("background-color: green")
                self.dlg.Schritt5.setStyleSheet("")

    # Erstellen des Multikanal-Bildes und Transformation in WGS84
    def GeocodeSentinel2(self):
        self.dlg.modifySentinel2.setEnabled(False)
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel2/ProcessedTiles"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel2/ProcessedTiles"
            )
        Anzahl_Sent1_Tiles = (
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel2/SingleTiles"
        )
        Tiles_Sent1 = int(
            sum(
                os.path.isfile(os.path.join(Anzahl_Sent1_Tiles, i))
                for i in os.listdir(Anzahl_Sent1_Tiles)
            )
            // 4
        )

        # Erstellen des RGB-Bildes/FCI-Bildes
        # Vorlage des Schritts: https://hatarilabs.com/ih-en/sentinel2-images-explotarion-and-processing-with-python-and-rasterio
        for TileNummer in range(1, Tiles_Sent1 + 1):
            band2 = rasterio.open(
                (
                    ""
                    + self.Workpath
                    + r"/EditTiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel2/SingleTiles/BlueCTile"
                    + str(TileNummer)
                    + ".jp2"
                ),
                driver="JP2OpenJPEG",
            )  # blue
            band3 = rasterio.open(
                (
                    ""
                    + self.Workpath
                    + r"/EditTiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel2/SingleTiles/GreenCTile"
                    + str(TileNummer)
                    + ".jp2"
                ),
                driver="JP2OpenJPEG",
            )  # green
            band4 = rasterio.open(
                (
                    ""
                    + self.Workpath
                    + r"/EditTiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel2/SingleTiles/RedCTile"
                    + str(TileNummer)
                    + ".jp2"
                ),
                driver="JP2OpenJPEG",
            )  # red
            band8 = rasterio.open(
                (
                    ""
                    + self.Workpath
                    + r"/EditTiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel2/SingleTiles/NIRTile"
                    + str(TileNummer)
                    + ".jp2"
                ),
                driver="JP2OpenJPEG",
            )  # nir
            # number of raster bands
            band4.count
            # number of raster columns
            band4.width
            # number of raster rows
            band4.height
            # type of raster byte
            band4.dtypes[0]
            # raster sytem of reference
            band4.crs
            # raster transform parameters
            band4.transform
            # raster values as matrix array
            band4.read(1)
            # export true color image
            if self.dlg.Sent2_Image_Typ.currentText() == "RGB-NIR-Image":
                trueColor = rasterio.open(
                    (
                        ""
                        + self.Workpath
                        + r"/EditTiles/"
                        + self.jahr
                        + self.monat
                        + self.tag
                        + "/Sentinel2/ProcessedTiles/ProcessedTile"
                        + str(TileNummer)
                        + ".tiff"
                    ),
                    "w",
                    driver="Gtiff",
                    width=band4.width,
                    height=band4.height,
                    count=4,
                    crs=band4.crs,
                    transform=band4.transform,
                    dtype=band4.dtypes[0],
                )
                trueColor.write(band2.read(1), 3)  # blue
                trueColor.write(band3.read(1), 2)  # green
                trueColor.write(band4.read(1), 1)  # red
                trueColor.write(band8.read(1), 4)  # NIR
                trueColor.close()
            if self.dlg.Sent2_Image_Typ.currentText() == "False-Color Image":
                falseColor = rasterio.open(
                    ""
                    + self.Workpath
                    + r"/EditTiles/"
                    + self.jahr
                    + self.monat
                    + self.tag
                    + "/Sentinel2/ProcessedTiles/ProcessedTile"
                    + str(TileNummer)
                    + ".tiff",
                    "w",
                    driver="Gtiff",
                    width=band2.width,
                    height=band2.height,
                    count=3,
                    crs=band2.crs,
                    transform=band2.transform,
                    dtype="uint16",
                )
                falseColor.write(band3.read(1), 3)  # Blue
                falseColor.write(band4.read(1), 2)  # Green
                falseColor.write(band8.read(1), 1)  # Red
                falseColor.close()

        # Transformieren der Daten in WGS84
        path_Sent2pro_Tiles = (
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + r"/Sentinel2/ProcessedTiles/"
        )
        tilessum_Sent2pro = sum(
            os.path.isfile(os.path.join(path_Sent2pro_Tiles, i))
            for i in os.listdir(path_Sent2pro_Tiles)
        )

        if not os.path.exists(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel2/ProcessedTiles_WGS84"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel2/ProcessedTiles_WGS84"
            )

        for Sent2pro_Tiles in range(1, tilessum_Sent2pro + 1):
            InputRasterFile = (
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel2/ProcessedTiles/ProcessedTile"
                + str(Sent2pro_Tiles)
                + ".tiff"
            )
            OutputRasterFile = (
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel2/ProcessedTiles_WGS84/ProcessedTile"
                + str(Sent2pro_Tiles)
                + "_WGS84.tiff"
            )
            dst_crs = "EPSG:4326"
            with rasterio.open(InputRasterFile) as src:
                transform, width, height = rasterio.warp.calculate_default_transform(
                    src.crs, dst_crs, src.width, src.height, *src.bounds
                )
                kwargs = src.meta.copy()
                kwargs.update(
                    {
                        "crs": dst_crs,
                        "transform": transform,
                        "width": width,
                        "height": height,
                    }
                )

                with rasterio.open(OutputRasterFile, "w", **kwargs) as dst:
                    for i in range(1, src.count + 1):
                        rasterio.warp.reproject(
                            source=rasterio.band(src, i),
                            destination=rasterio.band(dst, i),
                            src_transform=src.transform,
                            src_crs=src.crs,
                            dst_transform=transform,
                            dst_crs=dst_crs,
                            resampling=rasterio.warp.Resampling.nearest,
                        )

        self.dlg.Helper_Sent2.setChecked(False)

        if not self.dlg.Helper_Sent1.isChecked():
            if not self.dlg.Helper_Sent2.isChecked():
                self.dlg.Schritt4_check.setHidden(False)
                self.dlg.Schritt5.setEnabled(True)
                self.dlg.Schritt4.setEnabled(False)
                self.dlg.Schritt4.setStyleSheet("background-color: green")
                self.dlg.Schritt5.setStyleSheet("")
        if not self.dlg.Helper_Sent2.isChecked():
            if not self.dlg.Helper_Sent1.isChecked():
                self.dlg.Schritt4_check.setHidden(False)
                self.dlg.Schritt5.setEnabled(True)
                self.dlg.Schritt4.setEnabled(False)
                self.dlg.Schritt4.setStyleSheet("background-color: green")
                self.dlg.Schritt5.setStyleSheet("")

    # Öffnen der fünften Seite
    def Seite5(self):
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt5_Widget)
        self.dlg.Schritt5.setEnabled(False)

    # Zuschneiden der VIIRS-Daten
    def ClipVIIRS(self):
        self.dlg.editVIIRS.setEnabled(False)
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/VIIRS"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/GeoTIFFs/"
                + self.jahr
                + self.monat
                + self.tag
                + "/VIIRS"
            )
        clipped_VIIRS = (
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/VIIRS/NightLights"
            + self.jahr
            + self.monat
            + self.tag
            + "_clipped.tif"
        )
        VIIRS_Data = (
            ""
            + self.Workpath
            + r"/Downloadfiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/VIIRS/NightLights"
            + self.jahr
            + self.monat
            + self.tag
            + ".tif"
        )
        OutTile_VIIRS = gdal.Warp(
            clipped_VIIRS,
            VIIRS_Data,
            cutlineDSName=("" + self.Workpath + "/Geojson/Area_of_Interest.geojson"),
            cropToCutline=True,
            dstNodata=-0.0000001,
        )
        OutTile_VIIRS = None
        self.dlg.help_merge_VIIRS.setChecked(False)

    # Code ergänzen
    # Abfragen, ob Sent1, Sent2 und VIIRS nicht ausgewählt sind (weil es nicht gemacht werden soll,
    # oder, weil es schon erledigt ist und die Checkbox wieder auf false gesetzt worden ist)

    # Mergen und Clippen der Sentinel1-Daten
    def Merge_Clip_Sentinel1(self):
        self.dlg.editSentinel1.setEnabled(False)
        # mergen
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + r"/Sentinel1/MergedTiles"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + r"/Sentinel1/MergedTiles"
            )
        # Polarisation VV
        TilelistSent1_VV = []
        for Sent1VVname in sorted(
            glob.glob(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + r"/Sentinel1/GeocodedTiles/*VV*.tif"
            )
        ):
            TilelistSent1_VV.append(str(Sent1VVname))
        outputFile_Sentinel1_merged_VV = str(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + r"/Sentinel1/MergedTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "Sentinel1_Polarisation_VV_merged.tiff"
        )
        vrt_VV = gdal.BuildVRT(
            "merged_WGS.vrt", TilelistSent1_VV, srcNodata=0, VRTNodata=0
        )
        gdal.Translate(outputFile_Sentinel1_merged_VV, vrt_VV)
        vrt_VV = None

        # Polarisation VH
        TilelistSent1_VH = []
        for Sent1VHname in sorted(
            glob.glob(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + str(self.jahr)
                + str(self.monat)
                + str(self.tag)
                + r"/Sentinel1/GeocodedTiles/*VH*.tif"
            )
        ):
            TilelistSent1_VH.append(str(Sent1VHname))
        outputFile_Sentinel1_merged_VH = str(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + r"/Sentinel1/MergedTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "Sentinel1_Polarisation_VH_merged.tiff"
        )
        vrt_VH = gdal.BuildVRT(
            "merged_WGS.vrt", TilelistSent1_VH, srcNodata=0, VRTNodata=0
        )
        gdal.Translate(outputFile_Sentinel1_merged_VH, vrt_VH)
        vrt_VH = None

        # clippen VV
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel1"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/GeoTIFFs/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel1"
            )
        clipped_Sent1_VV = (
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel1/Sentinel1_"
            + self.jahr
            + self.monat
            + self.tag
            + "Polarisation_VV_clipped.tif"
        )
        OutTile_Sent1_VV = gdal.Warp(
            clipped_Sent1_VV,
            outputFile_Sentinel1_merged_VV,
            cutlineDSName=("" + self.Workpath + "/Geojson/Area_of_Interest.geojson"),
            cropToCutline=True,
            dstNodata=0,
        )
        OutTile_Sent1_VV = None

        # clippen VH
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel1"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/GeoTIFFs/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel1"
            )
        clipped_Sent1_VH = (
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel1/Sentinel1_"
            + self.jahr
            + self.monat
            + self.tag
            + "Polarisation_VH_clipped.tif"
        )
        OutTile_Sent1_VH = gdal.Warp(
            clipped_Sent1_VH,
            outputFile_Sentinel1_merged_VH,
            cutlineDSName=("" + self.Workpath + "/Geojson/Area_of_Interest.geojson"),
            cropToCutline=True,
            dstNodata=0,
        )
        OutTile_Sent1_VH = None
        self.dlg.help_merge_Sent1.setChecked(False)

    # Code ergänzen
    # Abfragen, ob Sent1, Sent2 und VIIRS nicht ausgewählt sind (weil es nicht gemacht werden soll,
    # oder, weil es schon erledigt ist und die Checkbox wieder auf false gesetzt worden ist)

    # Mergen und Clippen der Sentinel-2 Daten
    def Merge_Clip_Sentinel2(self):
        self.dlg.editSentinel2.setEnabled(False)
        # mergen
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel2/ProcessedTiles_WGS84_merged"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel2/ProcessedTiles_WGS84_merged"
            )
        TilelistSent2_WGS84 = []
        for name in sorted(
            glob.glob(
                ""
                + self.Workpath
                + r"/EditTiles/"
                + self.jahr
                + self.monat
                + self.tag
                + r"/Sentinel2/ProcessedTiles_WGS84/*.tiff"
            )
        ):
            TilelistSent2_WGS84.append(name)
        outputFile_Sentinel2_merged = (
            ""
            + self.Workpath
            + r"/EditTiles/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel2/ProcessedTiles_WGS84_merged/Sentinel2_"
            + self.jahr
            + self.monat
            + self.tag
            + "_WGS84_merged.tiff"
        )
        vrt = gdal.BuildVRT(
            "merged_WGS.vrt", TilelistSent2_WGS84, srcNodata=0, VRTNodata=0
        )
        gdal.Translate(outputFile_Sentinel2_merged, vrt)
        vrt = None
        # clippen
        if not os.path.exists(
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel2"
        ):
            os.mkdir(
                ""
                + self.Workpath
                + r"/GeoTIFFs/"
                + self.jahr
                + self.monat
                + self.tag
                + "/Sentinel2"
            )
        clipped_Sent2 = (
            ""
            + self.Workpath
            + r"/GeoTIFFs/"
            + self.jahr
            + self.monat
            + self.tag
            + "/Sentinel2/Sentinel2_"
            + self.jahr
            + self.monat
            + self.tag
            + "_clipped.tif"
        )
        OutTile_Sent2 = gdal.Warp(
            clipped_Sent2,
            outputFile_Sentinel2_merged,
            cutlineDSName=("" + self.Workpath + "/Geojson/Area_of_Interest.geojson"),
            cropToCutline=True,
            dstNodata=0,
        )
        OutTile_Sent2 = None
        self.dlg.help_merge_Sent2.setChecked(False)

    # Code ergänzen
    # Abfragen, ob Sent1, Sent2 und VIIRS nicht ausgewählt sind (weil es nicht gemacht werden soll,
    # oder, weil es schon erledigt ist und die Checkbox wieder auf false gesetzt worden ist)

    # Öffnen der sechsten Seite
    def Seite6(self):
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt6_Widget)
        self.dlg.Schritt6.setEnabled(False)

    # Sprung auf Seite drei zum neuen startDownload von Daten
    def ReturnSeite3(self):
        self.dlg.stackedWidget.setCurrentWidget(self.dlg.Schritt3_Widget)
        self.dlg.Schritt3.setEnabled(False)


# Lizenz zur Nutzung von rasterio:
# Rasterio license
# Copyright (c) 2016, MapBox All rights reserved.

# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

# Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

# Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

# Neither the name of Mapbox nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
